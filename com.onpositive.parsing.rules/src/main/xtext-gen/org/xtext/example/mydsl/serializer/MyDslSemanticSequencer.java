/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.ArgList;
import org.xtext.example.mydsl.myDsl.Assign;
import org.xtext.example.mydsl.myDsl.Call;
import org.xtext.example.mydsl.myDsl.Element;
import org.xtext.example.mydsl.myDsl.Function;
import org.xtext.example.mydsl.myDsl.Group;
import org.xtext.example.mydsl.myDsl.IntLiteral;
import org.xtext.example.mydsl.myDsl.Layer;
import org.xtext.example.mydsl.myDsl.Model;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Name;
import org.xtext.example.mydsl.myDsl.OrExp;
import org.xtext.example.mydsl.myDsl.PrimaryExpression;
import org.xtext.example.mydsl.myDsl.Rule;
import org.xtext.example.mydsl.myDsl.Seq;
import org.xtext.example.mydsl.myDsl.StringLiteral;
import org.xtext.example.mydsl.myDsl.TokenDefinition;
import org.xtext.example.mydsl.myDsl.TransferModel;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.ARG_LIST:
				sequence_ArgList(context, (ArgList) semanticObject); 
				return; 
			case MyDslPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case MyDslPackage.CALL:
				sequence_Call(context, (Call) semanticObject); 
				return; 
			case MyDslPackage.ELEMENT:
				sequence_Element(context, (Element) semanticObject); 
				return; 
			case MyDslPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case MyDslPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case MyDslPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case MyDslPackage.LAYER:
				sequence_Layer(context, (Layer) semanticObject); 
				return; 
			case MyDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case MyDslPackage.NAME:
				sequence_Name(context, (Name) semanticObject); 
				return; 
			case MyDslPackage.OR_EXP:
				sequence_OrExp(context, (OrExp) semanticObject); 
				return; 
			case MyDslPackage.PRIMARY_EXPRESSION:
				sequence_PrimaryExpression(context, (PrimaryExpression) semanticObject); 
				return; 
			case MyDslPackage.RULE:
				sequence_Rule(context, (Rule) semanticObject); 
				return; 
			case MyDslPackage.SEQ:
				sequence_Seq(context, (Seq) semanticObject); 
				return; 
			case MyDslPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case MyDslPackage.TOKEN_DEFINITION:
				sequence_TokenDefinition(context, (TokenDefinition) semanticObject); 
				return; 
			case MyDslPackage.TRANSFER_MODEL:
				sequence_TransferModel(context, (TransferModel) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ArgList returns ArgList
	 *
	 * Constraint:
	 *     (a+=PrimaryExpression a+=PrimaryExpression*)
	 */
	protected void sequence_ArgList(ISerializationContext context, ArgList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Assign returns Assign
	 *
	 * Constraint:
	 *     (name=ID (op='=' | op='+=' | op='*=') val=[TokenDefinition|ID])
	 */
	protected void sequence_Assign(ISerializationContext context, Assign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Call returns Call
	 *
	 * Constraint:
	 *     (name=[Function|ID] args=ArgList? op='?'?)
	 */
	protected void sequence_Call(ISerializationContext context, Call semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Element returns Element
	 *
	 * Constraint:
	 *     (val=Assign | val=StringLiteral | val=Group)
	 */
	protected void sequence_Element(ISerializationContext context, Element semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Group returns Group
	 *
	 * Constraint:
	 *     (seq=Seq (op='+' | op='?' | op='*')?)
	 */
	protected void sequence_Group(ISerializationContext context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     v=INT
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.INT_LITERAL__V) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.INT_LITERAL__V));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getVINTTerminalRuleCall_0(), semanticObject.getV());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Layer returns Layer
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Layer(ISerializationContext context, Layer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LAYER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LAYER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLayerAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         tokens+=TokenDefinition 
	 *         tokens+=TokenDefinition* 
	 *         functions+=Function 
	 *         functions+=Function* 
	 *         layers+=Layer 
	 *         layers+=Layer* 
	 *         rules+=Rule+
	 *     )
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Name returns Name
	 *
	 * Constraint:
	 *     v=ID
	 */
	protected void sequence_Name(ISerializationContext context, Name semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.NAME__V) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.NAME__V));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameAccess().getVIDTerminalRuleCall_0(), semanticObject.getV());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OrExp returns OrExp
	 *
	 * Constraint:
	 *     (options+=Element options+=Element*)
	 */
	protected void sequence_OrExp(ISerializationContext context, OrExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PrimaryExpression returns PrimaryExpression
	 *
	 * Constraint:
	 *     (c=Call | c=Name | c=IntLiteral | c=StringLiteral)
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, PrimaryExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Rule returns Rule
	 *
	 * Constraint:
	 *     (name=ID condition=Seq thenPart=TransferModel example=STRING layer=[Layer|ID]?)
	 */
	protected void sequence_Rule(ISerializationContext context, Rule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Seq returns Seq
	 *
	 * Constraint:
	 *     seq+=OrExp+
	 */
	protected void sequence_Seq(ISerializationContext context, Seq semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     v=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.STRING_LITERAL__V) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.STRING_LITERAL__V));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getVSTRINGTerminalRuleCall_0(), semanticObject.getV());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TokenDefinition returns TokenDefinition
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_TokenDefinition(ISerializationContext context, TokenDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TOKEN_DEFINITION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TOKEN_DEFINITION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTokenDefinitionAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TransferModel returns TransferModel
	 *
	 * Constraint:
	 *     (seq+=Call seq+=Call*)
	 */
	protected void sequence_TransferModel(ISerializationContext context, TransferModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
